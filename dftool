#!/usr/bin/env python
# pylint: disable=too-many-lines,too-many-statements
import datetime
import os
import sys

import functools
import brownie
from enforce_typing import enforce_types
from web3.middleware import geth_poa_middleware
from util import (
    allocations,
    blockrange,
    calcrewards,
    constants,
    csvs,
    dispense,
    getrate,
    networkutil,
    query,
)
from util.calcrewards import calcRewards
from util.retry import retryFunction
from util.base18 import fromBase18
from util.constants import BROWNIE_PROJECT as B
from util.networkutil import DEV_CHAINID, chainIdToMultisigAddr
from util.oceanutil import (
    recordDeployedContracts,
    OCEANtoken,
    veAllocate,
    create_lock_ve_ocean,
    increase_amount_ve_ocean,
    increase_unlock_time_ve_ocean,
    get_balance_ve_ocean,
    get_lock_end_ve_ocean,
    FeeDistributor
)

from util.blocktime import getfinBlock, timestrToTimestamp
from util.multisig import send_multisig_tx

brownie.network.web3.middleware_onion.inject(geth_poa_middleware, layer=0)

CHAINID_EXAMPLES = (
    f"{DEV_CHAINID} for development, 1 for (eth) mainnet, 137 for polygon"
)

# ve constants
WEEK = 7 * 86400
MAXTIME = 4 * 365 * 86400  # 4 years

# ========================================================================
HELP_MAIN = """Data Farming tool, for use by OPF.

Usage: dftool get_rate|query|calc|dispense|..
  
  # init actions
  dftool compile - compile contracts

  # data farming query & calc actions
  dftool calc ST FIN NSAMP CSV_DIR CHAINID - query chain, get (volumes, symbols, owners)
  dftool volsym ST FIN NSAMP CSV_DIR CHAINID - query chain, get (volumes, symbols, owners)
  dftool nftinfo CSV_DIR CHAINID [FIN] - Query chain, output nft_info csv
  dftool allocations ST FIN NSAMP CSV_DIR CHAINID
  dftool vebals ST FIN NSAMP CSV_DIR CHAINID - Query chain, outputs veBalances csv
  dftool get_rate TOKEN_SYMBOL ST FIN CSV_DIR - get exchange rate
  
  # web3 ops actions
  dftool dispense CSV_DIR [CHAINID] [DFREWARDS_ADDR] [TOKEN_ADDR] - from rewards, dispense funds
  dftool dispense_active CSV_DIR [CHAINID] [DFREWARDS_ADDR] [TOKEN_ADDR] - from rewards, dispense funds
  dftool checkpoint_feedist CHAINID - checkpoint FeeDistributor contract
  dftool dispense_passive CHAINID AMOUNT - dispense rewards in OCEAN on chainID

  dftool add_strategy CHAINID DFREWARDS_ADDR DFSTRATEGY_ADDR - Add a strategy to DFRewards contract
  dftool retire_strategy CHAINID DFREWARDS_ADDR DFSTRATEGY_ADDR - Retire a strategy from DFRewards contract

  # DFVE User Actions
  dftool create_lock_veocean CHAINID amount weeks - Lock an amount of OCEAN into veOCEAN for a set number of weeks. (for testing)
  dftool increase_lock_amount_veocean CHAINID amount - Increase the amount of Ocean in existing veOCEAN lock. (for testing)
  dftool increase_unlock_time_veocean CHAINID weeks - Increase the time of Ocean in existing veOCEAN lock. (for testing)
  dftool set_veallocation CHAINID amount exchangeId - Allocate weight to veAllocate contract. Set to 0 to reset. (for testing)
  
  # Debug Actions
  dftool many_random CHAINID - deploy many random tokens & nfts then consume (for testing)
  dftool mine BLOCKS [TIMEDELTA] - force chain to pass time (ganache only)
  dftool new_acct - generate new account
  dftool new_token CHAINID - generate new token (for testing)
  dftool new_veocean CHAINID TOKEN_ADDR - deploy veOcean using TOKEN_ADDR (for testing)
  dftool new_veallocate CHAINID - deploy veAllocate (for testing)
  dftool new_dfrewards CHAINID - deploy new DFRewards contract
  dftool new_dfstrategy CHAINID DFREWARDS_ADDR DFSTRATEGY_NAME - deploy new DFStrategy
  
  # Read Actions
  dftool acct_info CHAINID ACCOUNT_ADDR [TOKEN_ADDR] - info about an account
  dftool chain_info CHAINID - info about a network
  dftool get_balance_veocean CHAINID - Returns the total amount of veOCEAN. (for testing)
  dftool get_lock_end_veocean CHAINID - Get end time for veOcean lock (for testing).
  
  # Help Actions
  dftool help - this message

Transactions are signed with envvar 'DFTOOL_KEY`.
"""


@enforce_types
def do_help():
    print(HELP_MAIN)
    sys.exit(0)


# ========================================================================
@enforce_types
def do_volsym():
    HELP = f"""Query chain, output nft volumes, symbols, owners

Usage: dftool volsym ST FIN NSAMP CSV_DIR CHAINID
  ST -- first block # to calc on | YYYY-MM-DD | YYYY-MM-DD_HH:MM
  FIN -- last block # to calc on | YYYY-MM-DD | YYYY-MM-DD_HH:MM | latest
  NSAMP -- # blocks to sample liquidity from, from blocks [ST, ST+1, .., FIN]
  CSV_DIR -- output dir for stakes-CHAINID.csv, etc
  CHAINID -- {CHAINID_EXAMPLES}
  [RETRIES] -- optional, # times to retry failed queries

Uses these envvars:
ADDRESS_FILE -- eg: export ADDRESS_FILE={networkutil.chainIdToAddressFile(chainID=DEV_CHAINID)}
SECRET_SEED -- secret integer used to seed the rng
"""
    if len(sys.argv) not in [2 + 5, 2 + 6]:
        print(HELP)
        sys.exit(0)

    RETRIES = 1
    if len(sys.argv) == 2 + 6:
        RETRIES = int(sys.argv[7])

    # extract inputs
    assert sys.argv[1] == "query" or sys.argv[1] == "volsym"
    ST, FIN, NSAMP = sys.argv[2], sys.argv[3], int(sys.argv[4])
    CSV_DIR = sys.argv[5]
    CHAINID = int(sys.argv[6])
    print("dftool volsym: Begin")
    print(
        f"Arguments:\n "
        f"\n ST={ST}\n FIN={FIN}\n NSAMP={NSAMP}"
        f"\n CSV_DIR={CSV_DIR}"
        f"\n CHAINID={CHAINID}"
    )

    # extract envvars
    ADDRESS_FILE = _getAddressEnvvarOrExit()
    SECRET_SEED = _getSecretSeedOrExit()

    # check files, prep dir
    if not os.path.exists(CSV_DIR):
        print(f"\nDirectory {CSV_DIR} doesn't exist; nor do rates. Exiting.")
        sys.exit(0)
    if not csvs.rateCsvFilenames(CSV_DIR):
        print("\nRates don't exist. Call 'dftool get_rate' first. Exiting.")
        sys.exit(0)

    # brownie setup
    networkutil.connect(CHAINID)
    chain = brownie.network.chain
    rng = blockrange.create_range(chain, ST, FIN, NSAMP, SECRET_SEED)

    recordDeployedContracts(ADDRESS_FILE)
    # main work

    (Vi, Ci, SYMi) = retryFunction(
        query.queryVolsOwnersSymbols, RETRIES, 10, rng, CHAINID
    )
    csvs.saveNftvolsCsv(Vi, CSV_DIR, CHAINID)
    csvs.saveOwnersCsv(Ci, CSV_DIR, CHAINID)
    csvs.saveSymbolsCsv(SYMi, CSV_DIR, CHAINID)

    print("dftool volsym: Done")


# ========================================================================


@enforce_types
def do_nftinfo():
    HELP = f"""Query chain, output nft info csv
Usage: dftool nftinfo CSV_DIR CHAINID
    CSV_DIR -- output dir for nftinfo-CHAINID.csv
    CHAINID -- {CHAINID_EXAMPLES}
    [FIN] -- last block # to calc on | YYYY-MM-DD | YYYY-MM-DD_HH:MM | latest
"""
    if len(sys.argv) not in [4, 5]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "nftinfo"
    CSV_DIR = sys.argv[2]
    CHAINID = int(sys.argv[3])
    ENDBLOCK = sys.argv[4] if len(sys.argv) == 5 else "latest"
    networkutil.connect(CHAINID)
    chain = brownie.network.chain
    ENDBLOCK = getfinBlock(chain, ENDBLOCK)
    # create dir if not exists
    _createDirIfNeeded(CSV_DIR)

    # query.queryNftinfo() can be problematic; it's only used for frontend data
    # retry 3 times with 10s delay by default
    nftinfo = retryFunction(query.queryNftinfo, 3, 10, CHAINID, ENDBLOCK)
    csvs.saveNftinfoCsv(nftinfo, CSV_DIR, CHAINID)

    print("dftool nftinfo: Done")


# ========================================================================


@enforce_types
def do_allocations():
    HELP = f"""Query chain, outputs allocation csv

Usage: dftool allocations ST FIN NSAMP CSV_DIR CHAINID
  ST -- first block # to calc on | YYYY-MM-DD | YYYY-MM-DD_HH:MM
  FIN -- last block # to calc on | YYYY-MM-DD | YYYY-MM-DD_HH:MM | latest
  NSAMP -- # blocks to sample liquidity from, from blocks [ST, ST+1, .., FIN]
  CSV_DIR -- output dir for stakes-CHAINID.csv, etc
  CHAINID -- {CHAINID_EXAMPLES}
  [RETRIES] -- # times to retry failed queries

Uses these envvars:
SECRET_SEED -- secret integer used to seed the rng
"""
    if len(sys.argv) not in [7, 8]:
        print(HELP)
        sys.exit(0)

    RETRIES = 1
    if len(sys.argv) == 8:
        RETRIES = int(sys.argv[7])

    # extract inputs
    assert sys.argv[1] == "allocations"
    ST, FIN, NSAMP = sys.argv[2], sys.argv[3], int(sys.argv[4])
    CSV_DIR = sys.argv[5]
    CHAINID = int(sys.argv[6])

    # extract envvars
    SECRET_SEED = _getSecretSeedOrExit()

    # create dir if not exists
    _createDirIfNeeded(CSV_DIR)
    _exitIfFileExists(csvs.allocationCsvFilename(CSV_DIR, NSAMP > 1))

    # brownie setup
    networkutil.connect(CHAINID)
    chain = brownie.network.chain

    rng = blockrange.create_range(chain, ST, FIN, NSAMP, SECRET_SEED)

    allocs = retryFunction(query.queryAllocations, RETRIES, 10, rng, CHAINID)
    csvs.saveAllocationCsv(allocs, CSV_DIR, NSAMP > 1)

    print("dftool allocations: Done")


# ========================================================================


@enforce_types
def do_vebals():
    HELP = f"""Query chain, outputs veBalances csv

Usage: dftool vebals ST FIN NSAMP CSV_DIR CHAINID
  ST -- first block # to calc on | YYYY-MM-DD | YYYY-MM-DD_HH:MM
  FIN -- last block # to calc on | YYYY-MM-DD | YYYY-MM-DD_HH:MM | latest
  NSAMP -- # blocks to sample liquidity from, from blocks [ST, ST+1, .., FIN]
  CSV_DIR -- output dir for stakes-CHAINID.csv, etc
  CHAINID -- {CHAINID_EXAMPLES}
  [RETRIES] -- # times to retry failed queries

Uses these envvars:
SECRET_SEED -- secret integer used to seed the rng
"""
    if len(sys.argv) not in [7, 8]:
        print(HELP)
        sys.exit(0)

    RETRIES = 1
    if len(sys.argv) == 8:
        RETRIES = int(sys.argv[7])

    # extract inputs
    assert sys.argv[1] == "vebals"
    ST, FIN, NSAMP = sys.argv[2], sys.argv[3], int(sys.argv[4])
    CSV_DIR = sys.argv[5]
    CHAINID = int(sys.argv[6])

    # extract envvars
    SECRET_SEED = _getSecretSeedOrExit()

    # create a dir if not exists
    _createDirIfNeeded(CSV_DIR)
    _exitIfFileExists(csvs.vebalsCsvFilename(CSV_DIR, NSAMP > 1))

    # brownie setup
    networkutil.connect(CHAINID)
    chain = brownie.network.chain
    rng = blockrange.create_range(chain, ST, FIN, NSAMP, SECRET_SEED)

    balances, locked_amt, unlock_time = retryFunction(
        query.queryVebalances, RETRIES, 10, rng, CHAINID
    )
    csvs.saveVebalsCsv(balances, locked_amt, unlock_time, CSV_DIR, NSAMP > 1)

    print("dftool vebals: Done")


# ========================================================================
@enforce_types
def do_get_rate():
    HELP = """Get exchange rate, and output rate csv.

Usage: dftool get_rate TOKEN_SYMBOL ST FIN CSV_DIR
  TOKEN_SYMBOL -- e.g. OCEAN, H2O
  ST -- start time -- YYYY-MM-DD
  FIN -- end time -- YYYY-MM-DD
  CSV_DIR -- output directory for rate-TOKEN_SYMBOL.csv file
  [RETRIES] -- # times to retry failed queries
"""
    if len(sys.argv) not in [2 + 4, 2 + 5]:
        print(HELP)
        sys.exit(0)

    RETRIES = 1
    if len(sys.argv) == 2 + 5:
        RETRIES = int(sys.argv[2 + 4])

    # extract inputs
    assert sys.argv[1] == "get_rate"
    TOKEN_SYMBOL = sys.argv[2]
    ST, FIN = sys.argv[3], sys.argv[4]
    CSV_DIR = sys.argv[5]
    print(f"Arguments: ST={ST}, FIN={FIN}, CSV_DIR={CSV_DIR}")

    # check files, prep dir
    _exitIfFileExists(csvs.rateCsvFilename(TOKEN_SYMBOL, CSV_DIR))
    _createDirIfNeeded(CSV_DIR)

    # main work
    rate = retryFunction(get_rate.get_rate, RETRIES, 60, TOKEN_SYMBOL, ST, FIN)
    print(f"rate = ${rate:.4f} / {TOKEN_SYMBOL}")
    csvs.saveRateCsv(TOKEN_SYMBOL, rate, CSV_DIR)


# ========================================================================
@enforce_types
def do_calc():
    HELP = """From stakes/vols/rates csvs, output rewards csvs.

Usage: dftool calc CSV_DIR TOT_OCEAN [IGNORED]
  CSV_DIR -- directory: input csvs (stakes, vols, etc), output rewards.csv
  TOT_OCEAN -- total amount of TOKEN to distribute (decimal, not wei)
  IGNORED -- Ignored. This argument is kept for compatibility.
"""

    if len(sys.argv) not in [4, 5]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "calc"
    CSV_DIR = sys.argv[2]
    TOT_OCEAN = float(sys.argv[3])
    print(f"Arguments:\n TOT_OCEAN={TOT_OCEAN}, CSV_DIR={CSV_DIR}")

    # do we have the input files?
    alloc_fname = csvs.allocationCsvFilename(CSV_DIR)  # need for loadStakes()
    if not os.path.exists(alloc_fname):
        print(f"\nNo file {alloc_fname} in '{CSV_DIR}'. Exiting.")
        sys.exit(0)

    vebals_fname = csvs.vebalsCsvFilename(CSV_DIR)  # need for loadStakes()
    if not os.path.exists(vebals_fname):
        print(f"\nNo file {vebals_fname} in '{CSV_DIR}'. Exiting.")
        sys.exit(0)

    if not csvs.nftvolsCsvFilenames(CSV_DIR):
        print(f"\nNo 'nftvols*.csv' files in '{CSV_DIR}'. Exiting.")
        sys.exit(0)

    if not csvs.ownersCsvFilenames(CSV_DIR):
        print(f"\nNo 'owners*.csv' files in '{CSV_DIR}'. Exiting.")
        sys.exit(0)

    if not csvs.symbolsCsvFilenames(CSV_DIR):
        print(f"\nNo 'symbols*.csv' files in '{CSV_DIR}'. Exiting.")
        sys.exit(0)

    if not csvs.rateCsvFilenames(CSV_DIR):
        print(f"\nNo 'rate*.csv' files in '{CSV_DIR}'. Exiting.")
        sys.exit(0)

    # shouldn't already have the output file
    _exitIfFileExists(csvs.rewardsperlpCsvFilename(CSV_DIR, "OCEAN"))
    _exitIfFileExists(csvs.rewardsinfoCsvFilename(CSV_DIR, "OCEAN"))

    # main work
    S = allocations.loadStakes(CSV_DIR)
    V = csvs.loadNftvolsCsvs(CSV_DIR)
    C = csvs.loadOwnersCsvs(CSV_DIR)
    SYM = csvs.loadSymbolsCsvs(CSV_DIR)
    R = csvs.loadRateCsvs(CSV_DIR)
    do_pubrewards = constants.DO_PUBREWARDS
    do_rank = constants.DO_RANK

    cur_week = calcrewards.getDfWeekNumber(datetime.datetime.now())
    prev_week = cur_week - 1
    m = calcrewards.calcDcvMultiplier(prev_week)
    print(f"Given prev_week=DF{prev_week}, then DCV_multiplier={m}")

    rewperlp, rewinfo = calcRewards(
        S, V, C, SYM, R, m, TOT_OCEAN, do_pubrewards, do_rank
    )

    csvs.saveRewardsperlpCsv(rewperlp, CSV_DIR, "OCEAN")
    csvs.saveRewardsinfoCsv(rewinfo, CSV_DIR, "OCEAN")

    print("dftool calc: Done")


# ========================================================================
@enforce_types
def do_dispense_active():
    HELP = f"""From rewards csv, dispense funds to chain.

Usage: dftool dispense_active CSV_DIR [CHAINID] [DFREWARDS_ADDR] [TOKEN_ADDR] [BATCH_NBR]
  CSV_DIR -- input directory for csv rewards file
  CHAINID: CHAINID -- DFRewards contract's network.{CHAINID_EXAMPLES}. If not given, uses 1 (mainnet).
  DFREWARDS_ADDR -- DFRewards contract's address. If not given, uses envvar DFREWARDS_ADDR
  TOKEN_ADDR -- token contract's address. If not given, uses envvar TOKEN_ADDR
  BATCH_NBR -- specify the batch number to run dispense only for that batch. If not given, runs dispense for all batches.

Transactions are signed with envvar 'DFTOOL_KEY`.
"""
    if len(sys.argv) not in [4 + 0, 4 + 1, 4 + 2, 4 + 3]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "dispense" or sys.argv[1] == "dispense_active"
    CSV_DIR = sys.argv[2]

    if len(sys.argv) >= 4:
        CHAINID = int(sys.argv[3])
    else:
        CHAINID = 1

    if len(sys.argv) >= 5:
        DFREWARDS_ADDR = sys.argv[4]
    else:
        print("Set DFREWARDS_ADDR from envvar")
        DFREWARDS_ADDR = os.getenv("DFREWARDS_ADDR")

    if len(sys.argv) >= 6:
        TOKEN_ADDR = sys.argv[5]
    else:
        print("Set TOKEN_ADDR from envvar")
        TOKEN_ADDR = os.getenv("TOKEN_ADDR")

    BATCH_NBR = None
    if len(sys.argv) >= 7:
        BATCH_NBR = int(sys.argv[6])

    print(
        f"Arguments: CSV_DIR={CSV_DIR}, CHAINID={CHAINID}"
        f", DFREWARDS_ADDR={DFREWARDS_ADDR}, TOKEN_ADDR={TOKEN_ADDR}"
        f", BATCH_NBR={BATCH_NBR}"
    )
    assert DFREWARDS_ADDR is not None
    assert TOKEN_ADDR is not None

    # main work
    networkutil.connect(CHAINID)
    from_account = _getPrivateAccount()
    token_symbol = B.Simpletoken.at(TOKEN_ADDR).symbol().upper()
    token_symbol = token_symbol.replace("MOCEAN", "OCEAN")
    rewards = csvs.loadRewardsCsv(CSV_DIR, token_symbol)

    # "flatten" the rewards dict to dispense all chains in one go
    all_rewards = calcrewards.flattenRewards(rewards)
    # dispense
    dispense.dispense(
        all_rewards,
        DFREWARDS_ADDR,
        TOKEN_ADDR,
        from_account,
        batch_number=BATCH_NBR,
    )

    print("dftool dispense: Done")


# ========================================================================
@enforce_types
def do_new_dfrewards():
    HELP = f"""Deploy new DFRewards contract.

Usage: dftool new_dfrewards CHAINID
  CHAINID -- {CHAINID_EXAMPLES}
"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "new_dfrewards"
    CHAINID = int(sys.argv[2])

    print(f"Arguments: CHAINID={CHAINID}")

    # main work
    networkutil.connect(CHAINID)
    from_account = _getPrivateAccount()
    df_rewards = B.DFRewards.deploy({"from": from_account})
    print(f"New DFRewards contract deployed at address: {df_rewards.address}")

    print("dftool new_dfrewards: Done")


# ========================================================================
@enforce_types
def do_new_dfstrategy():
    HELP = f"""Deploy new DFStrategy contract.

Usage: dftool new_dfstrategy CHAINID DFREWARDS_ADDR DFSTRATEGY_NAME
  CHAINID -- {CHAINID_EXAMPLES}
  DFREWARDS_ADDR -- DFRewards contract address
  DFSTRATEGY_NAME -- DFStrategy contract name
"""
    if len(sys.argv) not in [5]:
        print(HELP)
        sys.exit(0)

    assert sys.argv[1] == "new_dfstrategy"
    CHAINID = int(sys.argv[2])
    DFREWARDS_ADDR = sys.argv[3]
    DFSTRATEGY_NAME = sys.argv[4]

    print(f"Arguments: CHAINID={CHAINID}")

    networkutil.connect(CHAINID)
    from_account = _getPrivateAccount()
    df_strategy = B[DFSTRATEGY_NAME].deploy(DFREWARDS_ADDR, {"from": from_account})
    print(f"New DFStrategy contract deployed at address: {df_strategy.address}")

    print("dftool new_dfstrategy: Done")


# ========================================================================
@enforce_types
def do_add_strategy():
    HELP = f"""Add a strategy to DFRewards contract.

Usage: dftool add_strategy CHAINID DFREWARDS_ADDR DFSTRATEGY_ADDR
  CHAINID -- {CHAINID_EXAMPLES}
  DFREWARDS_ADDR -- DFRewards contract address
  DFSTRATEGY_ADDR -- DFStrategy contract address
"""
    if len(sys.argv) not in [5]:
        print(HELP)
        sys.exit(0)

    assert sys.argv[1] == "add_strategy"
    CHAINID = int(sys.argv[2])
    DFREWARDS_ADDR = sys.argv[3]
    DFSTRATEGY_ADDR = sys.argv[4]

    print(f"Arguments: CHAINID={CHAINID}")

    networkutil.connect(CHAINID)
    from_account = _getPrivateAccount()
    df_rewards = B.DFRewards.at(DFREWARDS_ADDR)
    tx = df_rewards.add_strategy(DFSTRATEGY_ADDR, {"from": from_account})
    assert tx.events.keys()[0] == "StrategyAdded"

    print(f"Strategy {DFSTRATEGY_ADDR} added to DFRewards {df_rewards.address}")

    print("dftool add_strategy: Done")


# ========================================================================
@enforce_types
def do_retire_strategy():
    HELP = f"""Retire a strategy from DFRewards contract.

Usage: dftool retire_strategy CHAINID DFREWARDS_ADDR DFSTRATEGY_ADDR
  CHAINID -- {CHAINID_EXAMPLES}
  DFREWARDS_ADDR -- DFRewards contract address
  DFSTRATEGY_ADDR -- DFStrategy contract address
"""
    if len(sys.argv) not in [5]:
        print(HELP)
        sys.exit(0)

    assert sys.argv[1] == "retire_strategy"
    CHAINID = int(sys.argv[2])
    DFREWARDS_ADDR = sys.argv[3]
    DFSTRATEGY_ADDR = sys.argv[4]

    print(f"Arguments: CHAINID={CHAINID}")

    networkutil.connect(CHAINID)
    from_account = _getPrivateAccount()
    df_rewards = B.DFRewards.at(DFREWARDS_ADDR)
    tx = df_rewards.retire_strategy(DFSTRATEGY_ADDR, {"from": from_account})
    assert tx.events.keys()[0] == "StrategyRetired"
    print(f"Strategy {DFSTRATEGY_ADDR} retired from DFRewards {df_rewards.address}")

    print("dftool add_strategy: Done")


# ========================================================================
@enforce_types
def do_compile():
    HELP = """Compile contracts

Usage: dftool compile
"""
    if len(sys.argv) not in [2]:
        print(HELP)
        sys.exit(0)

    os.system("brownie compile")


# ========================================================================
@enforce_types
def do_many_random():
    # UPADATE THIS
    HELP = f"""Deploy many random tokens & nfts then consume (for testing)

Usage: dftool many_random CHAINID
  CHAINID -- {CHAINID_EXAMPLES}

Uses these envvars:
ADDRESS_FILE -- eg: export ADDRESS_FILE={networkutil.chainIdToAddressFile(chainID=DEV_CHAINID)}
"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    from util import oceantestutil  # pylint: disable=import-outside-toplevel

    # extract inputs
    assert sys.argv[1] == "many_random"
    CHAINID = int(sys.argv[2])
    print("dftool many_random: Begin")
    print(f"Arguments: CHAINID={CHAINID}")

    if CHAINID != DEV_CHAINID:
        # To support other testnets, they need to fillAccountsWithOcean()
        # Consider this a TODO:)
        print("Only ganache is currently supported. Exiting.")
        sys.exit(0)

    # extract envvars
    ADDRESS_FILE = _getAddressEnvvarOrExit()

    # brownie setup
    networkutil.connect(CHAINID)

    # main work
    recordDeployedContracts(ADDRESS_FILE)
    oceantestutil.fillAccountsWithOCEAN()
    num_nfts = 10  # magic number

    # This fn was deprecated, replace.
    # oceantestutil.randomDeployTokensAndPoolsThenConsume(num_pools, OCEANtoken())
    print(f"dftool many_random: Done. {num_nfts} new nfts created.")


# ========================================================================
@enforce_types
def do_mine():
    HELP = """Force chain to pass time (ganache only).

Usage: dftool mine BLOCKS [TIMEDELTA]
  BLOCKS -- e.g. 3
  TIMEDELTA -- e.g. 100
"""
    if len(sys.argv) not in [3, 4]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "mine"
    BLOCKS = int(sys.argv[2])
    if len(sys.argv) == 4:
        TIMEDELTA = int(sys.argv[3])
    else:
        TIMEDELTA = None

    print(f"Arguments: BLOCKS={BLOCKS}, TIMEDELTA={TIMEDELTA}")

    # main work
    networkutil.connect(DEV_CHAINID)
    chain = brownie.network.chain
    if TIMEDELTA is None:
        chain.mine(blocks=BLOCKS, timedelta=TIMEDELTA)
    else:
        chain.mine(blocks=BLOCKS)

    print("dftool mine: Done")


# ========================================================================
@enforce_types
def do_new_acct():
    HELP = """Generate new account.

Usage: dftool new_acct
"""
    if len(sys.argv) not in [2]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "new_acct"

    # main work
    networkutil.connect(DEV_CHAINID)
    account = brownie.network.accounts.add()
    print("Generated new account:")
    print(f" private_key = {account.private_key}")
    print(f" address = {account.address}")
    print(f" For other dftools: export DFTOOL_KEY={account.private_key}")


# ========================================================================
@enforce_types
def do_new_token():
    HELP = """Generate new token (for testing).

Usage: dftool new_token CHAINID
"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "new_token"
    CHAINID = int(sys.argv[2])
    print(f"Arguments:\n CHAINID={CHAINID}")

    # main work
    networkutil.connect(CHAINID)
    from_account = _getPrivateAccount()
    token = B.Simpletoken.deploy("TST", "Test Token", 18, 1e21, {"from": from_account})
    print(f"Token '{token.symbol()}' deployed at address: {token.address}")


# ========================================================================
@enforce_types
def do_new_veocean():
    HELP = """Generate new veOcean (for testing).

Usage: dftool new_veocean CHAINID TOKEN_ADDR
"""
    if len(sys.argv) not in [4]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "new_veocean"
    CHAINID = int(sys.argv[2])
    print(f"Arguments:\n CHAINID={CHAINID}")

    TOKEN_ADDR = str(sys.argv[3])
    print(f"Arguments:\n TOKEN_ADDR={TOKEN_ADDR}")

    # main work
    networkutil.connect(CHAINID)
    from_account = _getPrivateAccount()

    # deploy veOcean
    veOcean = B.veOcean.deploy(
        TOKEN_ADDR, "veOCEAN", "veOCEAN", "0.1", {"from": from_account}
    )
    # pylint: disable=line-too-long
    print(
        f"veOcean '{veOcean.symbol()}' deployed at address: {veOcean.address} with token parameter pointing at: {veOcean.token}"
    )


# ========================================================================
@enforce_types
def do_create_lock_veocean():
    HELP = """Lock Ocean (for testing).
    
Usage: dftool create_lock_veocean CHAINID amount weeks
"""
    if len(sys.argv) not in [5]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "create_lock_veocean"
    CHAINID = int(sys.argv[2])
    print(f"Arguments:\n CHAINID={CHAINID}")

    amount = float(sys.argv[3])
    print(f"Arguments:\n amount={amount}")

    weeks = int(sys.argv[4])
    print(f"Arguments:\n weeks={weeks}")

    # main work
    networkutil.connect(CHAINID)
    ADDRESS_FILE = os.environ.get("ADDRESS_FILE")
    if ADDRESS_FILE is not None:
        recordDeployedContracts(ADDRESS_FILE)
        from_account = _getPrivateAccount()

        # Lock ocean for a certain number of weeks
        end_time = brownie.network.chain.time() + WEEK * weeks

        ve_balance = get_balance_ve_ocean(from_account)
        print(f"before: veOCEAN balance: {ve_balance}")

        create_lock_ve_ocean(amount, end_time, from_account)

        ve_balance = get_balance_ve_ocean(from_account)
        print(f"after: veOCEAN balance: {ve_balance}")


# ========================================================================
@enforce_types
def do_increase_unlock_time_veocean():
    HELP = """Increase the time of Ocean locked inside veOcean (for testing).
    
Usage: dftool increase_unlock_time_veocean CHAINID weeks
"""
    if len(sys.argv) not in [4]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "increase_unlock_time_veocean"
    CHAINID = int(sys.argv[2])
    print(f"Arguments:\n CHAINID={CHAINID}")

    weeks = int(sys.argv[3])
    print(f"Arguments:\n weeks={weeks}")

    # main work
    networkutil.connect(CHAINID)
    ADDRESS_FILE = os.environ.get("ADDRESS_FILE")
    if ADDRESS_FILE is not None:
        recordDeployedContracts(ADDRESS_FILE)
        from_account = _getPrivateAccount()

        # Lock ocean for a certain number of weeks
        end_time = brownie.network.chain.time() + WEEK * weeks

        ve_lock_end = get_lock_end_ve_ocean(from_account)
        print(f"before: veOCEAN lock end: {ve_lock_end}")

        increase_unlock_time_ve_ocean(end_time, from_account)

        ve_lock_end = get_lock_end_ve_ocean(from_account)
        print(f"after: veOCEAN lock end: {ve_lock_end}")


# ========================================================================
@enforce_types
def do_increase_lock_amount_veocean():
    HELP = """Increase the amount of Ocean locked inside veOcean (for testing).
    
Usage: dftool increase_lock_amount_veocean CHAINID amount
"""
    if len(sys.argv) not in [4]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "increase_lock_amount_veocean"
    CHAINID = int(sys.argv[2])
    print(f"Arguments:\n CHAINID={CHAINID}")

    amount = float(sys.argv[3])
    print(f"Arguments:\n amount={amount}")

    # main work
    networkutil.connect(CHAINID)
    ADDRESS_FILE = os.environ.get("ADDRESS_FILE")
    if ADDRESS_FILE is not None:
        recordDeployedContracts(ADDRESS_FILE)
        from_account = _getPrivateAccount()

        ve_balance = get_balance_ve_ocean(from_account)
        print(f"before: veOCEAN balance: {ve_balance}")

        increase_amount_ve_ocean(amount, from_account)

        ve_balance = get_balance_ve_ocean(from_account)
        print(f"after: veOCEAN balance: {ve_balance}")


# ========================================================================
@enforce_types
def do_get_lock_end_veocean():
    HELP = """Get end time for veOcean lock (for testing).
    
Usage: dftool get_lock_end_veocean CHAINID
"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "get_lock_end_veocean"
    CHAINID = int(sys.argv[2])
    print(f"Arguments:\n CHAINID={CHAINID}")

    # main work
    networkutil.connect(CHAINID)
    ADDRESS_FILE = os.environ.get("ADDRESS_FILE")
    if ADDRESS_FILE is not None:
        recordDeployedContracts(ADDRESS_FILE)
        from_account = _getPrivateAccount()

        ve_lock_end = get_lock_end_ve_ocean(from_account)
        print(f"veOCEAN lock end time: {ve_lock_end}")


# ========================================================================
@enforce_types
def do_new_veallocate():
    HELP = """Generate new veAllocate (for testing).

Usage: dftool new_veallocate CHAINID
"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "new_veallocate"
    CHAINID = int(sys.argv[2])
    print(f"Arguments:\n CHAINID={CHAINID}")

    # main work
    networkutil.connect(CHAINID)
    from_account = _getPrivateAccount()
    contract = B.veAllocate.deploy({"from": from_account})
    print(f"veAllocate contract deployed at: {contract.address}")


# ========================================================================
@enforce_types
def do_get_balance_veocean():
    HELP = """Get veOcean balance on a specific chain (for testing).
    
Usage: dftool get_balance_veocean CHAINID
"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "get_balance_veocean"
    CHAINID = int(sys.argv[2])
    print(f"Arguments:\n CHAINID={CHAINID}")

    # main work
    networkutil.connect(CHAINID)
    ADDRESS_FILE = os.environ.get("ADDRESS_FILE")
    if ADDRESS_FILE is not None:
        recordDeployedContracts(ADDRESS_FILE)
        from_account = _getPrivateAccount()
        veBalance = get_balance_ve_ocean(from_account)
        print(f"veOCEAN balance: {veBalance}")


# ========================================================================
@enforce_types
def do_set_veallocation():
    HELP = """Allocate weight to veAllocate contract (for testing).
    Set to 0 to trigger resetAllocation event.

Usage: dftool set_veallocation CHAINID amount exchangeId
"""
    if len(sys.argv) not in [5]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "set_veallocation"
    CHAINID = int(sys.argv[2])
    print(f"Arguments:\n CHAINID={CHAINID}")

    amount = float(sys.argv[3])
    print(f"Arguments:\n amount={amount}")

    exchangeId = str(sys.argv[4])
    print(f"Arguments:\n exchangeId={exchangeId}")

    # main work
    networkutil.connect(CHAINID)
    ADDRESS_FILE = os.environ.get("ADDRESS_FILE")
    if ADDRESS_FILE is not None:
        recordDeployedContracts(ADDRESS_FILE)
        from_account = _getPrivateAccount()
        veAllocate().setAllocation(amount, exchangeId, CHAINID, {"from": from_account})
        allocation = veAllocate().getTotalAllocation(from_account)
        print(f"amount allocated: {allocation}")


# ========================================================================
@enforce_types
def do_acct_info():
    HELP = f"""Info about an account.

Usage: dftool acct_info CHAINID ACCOUNT_ADDR [TOKEN_ADDR]
  CHAINID -- {CHAINID_EXAMPLES}
  ACCOUNT_ADDR -- e.g. '0x987...' or '4'. If the latter, uses accounts[i]
  TOKEN_ADDR -- e.g. '0x123..'

If envvar ADDRESS_FILE is not None, it gives balance for OCEAN token too.
"""
    if len(sys.argv) not in [4, 5]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "acct_info"
    CHAINID = int(sys.argv[2])
    ACCOUNT_ADDR = sys.argv[3]
    TOKEN_ADDR = sys.argv[4] if len(sys.argv) >= 5 else None

    # do work
    print("Account info:")
    networkutil.connect(CHAINID)
    if len(str(ACCOUNT_ADDR)) == 1:
        addr_i = int(ACCOUNT_ADDR)
        ACCOUNT_ADDR = brownie.accounts[addr_i]
    print(f"  Address = {ACCOUNT_ADDR}")

    if TOKEN_ADDR is not None:
        token = B.Simpletoken.at(TOKEN_ADDR)
        balance = token.balanceOf(ACCOUNT_ADDR)
        print(f"  {fromBase18(balance)} {token.symbol()}")

    # Give balance for OCEAN token too.
    ADDRESS_FILE = os.environ.get("ADDRESS_FILE")
    if ADDRESS_FILE is not None:
        recordDeployedContracts(ADDRESS_FILE)
        OCEAN = OCEANtoken()
        if OCEAN.address != TOKEN_ADDR:
            print(f"  {fromBase18(OCEAN.balanceOf(ACCOUNT_ADDR))} OCEAN")


# ========================================================================
@enforce_types
def do_chain_info():
    HELP = f"""Info about a network.

Usage: dftool chain_info CHAINID
  CHAINID -- {CHAINID_EXAMPLES}
"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "chain_info"
    CHAINID = int(sys.argv[2])

    # do work
    networkutil.connect(CHAINID)
    # blocks = len(brownie.network.chain)
    print("\nChain info:")
    print(f"  # blocks: {len(brownie.network.chain)}")


# ========================================================================
@enforce_types
def do_dispense_passive_rewards():
    HELP = f"""Dispense passive rewards.

Usage: dftool dispense_passive CHAINID AMOUNT
    CHAINID -- {CHAINID_EXAMPLES}
"""
    if len(sys.argv) not in [4]:
        print(HELP)
        sys.exit(0)

    CHAINID = int(sys.argv[2])
    networkutil.connect(CHAINID)
    AMOUNT = float(sys.argv[3])
    ADDRESS_FILE = _getAddressEnvvarOrExit()

    recordDeployedContracts(ADDRESS_FILE)
    feedist = FeeDistributor()
    OCEAN = OCEANtoken()
    dispense.dispense_passive(OCEAN, feedist, AMOUNT)

    print("Dispensed passive rewards")


# ========================================================================
@enforce_types
def do_calculate_passive():
    HELP = f"""Calculate passive rewards.

Usage: dftool calculate_passive CHAINID DATE CSV_DIR
    CHAINID -- {CHAINID_EXAMPLES}
    DATE -- date in format YYYY-MM-DD
    CSV_DIR -- output dir for passive-CHAINID.csv
"""
    if len(sys.argv) not in [5]:
        print(HELP)
        sys.exit(0)

    CHAINID = int(sys.argv[2])
    networkutil.connect(CHAINID)
    DATE = sys.argv[3]
    CSV_DIR = sys.argv[4]
    timestamp = int(timestrToTimestamp(DATE))
    S_PER_WEEK = 7 * 86400
    timestamp = timestamp // S_PER_WEEK * S_PER_WEEK
    ADDRESS_FILE = _getAddressEnvvarOrExit()
    recordDeployedContracts(ADDRESS_FILE)

    # load vebals csv file
    passive_fname = csvs.passiveCsvFilename(CSV_DIR)
    vebals_realtime_fname = csvs.vebalsCsvFilename(CSV_DIR, False)
    if not os.path.exists(vebals_realtime_fname):
        print(f"\nNo file {vebals_realtime_fname} in '{CSV_DIR}'. Exiting.")
        sys.exit(0)
    _exitIfFileExists(passive_fname)

    # get addresses
    vebals, _, _ = csvs.loadVebalsCsv(CSV_DIR, False)
    addresses = list(vebals.keys())

    balances, rewards = query.queryPassiveRewards(timestamp, addresses)

    # save to csv
    csvs.savePassiveCsv(rewards, balances, CSV_DIR)


# ========================================================================
@enforce_types
def do_checkpoint_feedist():
    HELP = f"""Checkpoint FeeDistributor contract.

Usage: dftool checkpoint_feedist CHAINID
    CHAINID -- {CHAINID_EXAMPLES}
"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    CHAINID = int(sys.argv[2])
    networkutil.connect(CHAINID)

    ADDRESS_FILE = _getAddressEnvvarOrExit()

    recordDeployedContracts(ADDRESS_FILE)
    from_account = _getPrivateAccount()

    try:
        feedist.checkpoint_total_supply({"from": from_account})
        feedist.checkpoint_token({"from": from_account})
    # pylint: disable=broad-exception-caught
    except Exception as e:
        print(f"Checkpoint failed: {e}, submitting tx to multisig")
        total_supply_encoded = feedist.checkpoint_total_supply.encode_input()
        checkpoint_token_encoded = feedist.checkpoint_token.encode_input()

        to = feedist.address
        value = 0
        multisig_addr = chainIdToMultisigAddr(brownie.network.chain.id)

        # submit transactions to multisig
        send_multisig_tx(multisig_addr, to, value, total_supply_encoded)
        send_multisig_tx(multisig_addr, to, value, checkpoint_token_encoded)

    print("Checkpointed FeeDistributor")


# ========================================================================
# utilities


def _exitIfFileExists(filename: str):
    if os.path.exists(filename):
        print(f"\nFile {filename} exists. Exiting.")
        sys.exit(0)


def _createDirIfNeeded(dir_: str):
    if not os.path.exists(dir_):
        print(f"Directory {dir_} did not exist, so created it")
        os.mkdir(dir_)


def _getAddressEnvvarOrExit() -> str:
    ADDRESS_FILE = os.environ.get("ADDRESS_FILE")
    print(f"Envvar:\n ADDRESS_FILE={ADDRESS_FILE}")
    if ADDRESS_FILE is None:
        print(
            "\nNeed to set envvar ADDRESS_FILE. Exiting. "
            f"\nEg: export ADDRESS_FILE={networkutil.chainIdToAddressFile(chainID=DEV_CHAINID)}"
        )
        sys.exit(0)
    return ADDRESS_FILE


def _getSecretSeedOrExit() -> int:
    SECRET_SEED = os.environ.get("SECRET_SEED")
    print(f"Envvar:\n SECRET_SEED={SECRET_SEED}")
    if SECRET_SEED is None:
        print("\nNeed to set envvar SECRET_SEED. Exiting. \nEg: export SECRET_SEED=1")
        sys.exit(0)
    return int(SECRET_SEED)


@enforce_types
def _getPrivateAccount():
    private_key = os.getenv("DFTOOL_KEY")
    assert private_key is not None, "Need to set envvar DFTOOL_KEY"
    account = brownie.network.accounts.add(private_key=private_key)
    print(f"For private key DFTOOL_KEY, address is: {account.address}")
    return account


ARGV_FNS = {
    # init
    "compile" : do_compile,
    "help" : do_help,
    # df query & calc
    "query" : do_volsym,
    "volsym" : do_volsym,
    "nftinfo" : do_nftinfo,
    "allocations" : do_allocations,
    "vebals" : do_vebals,
    "get_rate" : do_get_rate,
    "calc" : do_calc,
    # web3 ops actions
    "dispense" : do_dispense_active,
    "dispense_active" : do_dispense_active,
    "checkpoint_feedist" : do_checkpoint_feedist,
    "dispense_passive" : do_dispense_passive_rewards,
    "calculate_passive" : do_calculate_passive,
    "new_dfrewards" : do_new_dfrewards,
    "new_dfstrategy" : do_new_dfstrategy,
    "add_strategy" : do_add_strategy,
    "retire_strategy" : do_retire_strategy,
    # dfve user actions
    "create_lock_veocean" : do_create_lock_veocean,
    "increase_unlock_time_veocean" : do_increase_unlock_time_veocean,
    "increase_lock_amount_veocean" : do_increase_lock_amount_veocean,
    "set_veallocation" : do_set_veallocation,
    # read actions
    "acct_info" : do_acct_info,
    "chain_info" : do_chain_info,
    "get_balance_veocean" : do_get_balance_veocean,
    "get_lock_end_veocean" : do_get_lock_end_veocean,
    # debug actions
    "many_random" : do_many_random,
    "mine" : do_mine,
    "new_acct" : do_new_acct,
    "new_token" : do_new_token,
    "new_veocean" : do_new_veocean,
    "new_veallocate" : do_new_veallocate,
}


# ========================================================================
# main
@enforce_types
def do_main():
    # if help
    if len(sys.argv) == 1 :
        do_help()
    else:
        if sys.argv[1] in ARGV_FNS:
            ARGV_FNS[sys.argv[1]]()
        else:
            do_help()


if __name__ == "__main__":
    do_main()
